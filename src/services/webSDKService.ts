import { hikCentralService } from './hikvisionService';
import { hikCentralScrapingService } from './hikCentralScrapingService';
import { logger } from '@/utils/secureLogger';
import { normalizeName } from '@/utils/normalizeText';

export interface VisitorData {
  nome: string;
  cpf: string;
  telefone: string;
  email: string;
  documento: string;
  foto?: string;
  moradorNome?: string;
  moradorUnidade?: string;
  moradorId?: string;
  validadeDias?: number;
}

export interface DeviceConfig {
  ip: string;
  port: number;
  username: string;
  password: string;
  name: string;
  type: 'entrada' | 'saida';
}

export interface WebSDKResponse {
  success: boolean;
  message: string;
  data?: any;
}

export class HikVisionWebSDKService {
  private collectors: DeviceConfig[] = [
    { ip: '192.168.1.205', port: 80, username: 'luca', password: 'Luca123#', name: 'Entrada Visitante 2', type: 'entrada' },
    { ip: '192.168.1.210', port: 80, username: 'luca', password: 'Luca123#', name: 'Entrada Catraca Prestador', type: 'entrada' },
    { ip: '192.168.1.207', port: 80, username: 'luca', password: 'Luca123#', name: 'Entrada Caminh√£o Baixo', type: 'entrada' },
    { ip: '192.168.1.207', port: 80, username: 'luca', password: 'Luca123#', name: 'Sa√≠da Caminh√£o Baixo', type: 'saida' },
    { ip: '192.168.1.206', port: 80, username: 'luca', password: 'Luca123#', name: 'Sa√≠da Catraca Prestador', type: 'saida' }
  ];

  async createVisitorInHikCentral(visitor: VisitorData): Promise<WebSDKResponse> {
    logger.info(`üö™ Criando visitante via FILA SUPABASE: ${visitor.nome}`);
    
    try {
      const validadeDias = visitor.validadeDias || 1;
      const validadeAte = new Date();
      validadeAte.setDate(validadeAte.getDate() + validadeDias);
      validadeAte.setHours(23, 59, 59, 999);

      logger.info('üì§ Enviando visitante para fila de processamento...');
      
      // Importar servi√ßo de fila
      const { queueService } = await import('./queueService');
      
      // Preparar dados para fila
      const moradorNomeOriginal = (visitor as any).moradorNome || '';
      const moradorNomeNormalizado = moradorNomeOriginal ? normalizeName(moradorNomeOriginal) : '';
      
      console.log('üè† Normalizando nome do morador:');
      console.log(`   Original: "${moradorNomeOriginal}"`);
      console.log(`   Normalizado: "${moradorNomeNormalizado}"`);
      
      const queueData = {
        nome: visitor.nome,
        telefone: visitor.telefone || '',
        cpf: visitor.cpf || '',
        rg: visitor.documento || '',
        placa: (visitor as any).placa_veiculo || '',
        genero: (visitor as any).genero || 'Masculino',
        morador_nome: moradorNomeNormalizado, // ‚úÖ NOME DO MORADOR NORMALIZADO (SEM ACENTOS)
        action: (visitor as any).action || 'create', // ‚≠ê NOVO: 'create' ou 'reactivate'
        validade_dias: visitor.validadeDias || 1, // ‚≠ê DURA√á√ÉO EM DIAS
        photo_base64: visitor.foto // ‚≠ê FOTO EM BASE64
      };
      
      logger.info('üì∏ Foto inclu√≠da:', visitor.foto ? 'SIM' : 'N√ÉO');
      console.log('üìã Dados que ser√£o enviados para fila:', queueData);
      
      const result = await queueService.sendToQueue(queueData);
      
      if (!result.success) {
        throw new Error(result.error || 'Falha ao enviar para fila');
      }
      
      console.log('‚úÖ Visitante enviado para fila com ID:', result.id);
      
      return {
        success: true,
        message: `Visitante ${visitor.nome} enviado para processamento. ID: ${result.id}`,
        data: {
          queueId: result.id,
          grupo: 'VisitanteS',
          visitado: visitor.moradorNome,
          validade: validadeAte.toISOString(),
          coletores: 0,
          method: 'QUEUE_PROCESSING',
          photo_processed: !!visitor.foto
        }
      };

    } catch (error) {
      console.error('‚ùå Erro ao enviar visitante para fila:', error);
      return {
        success: false,
        message: `Erro ao enviar visitante para fila: ${error}`
      };
    }
  }

  // Fallback: Criar diretamente nos coletores se proxy falhar
  async createUserInCollectorsFallback(visitor: VisitorData): Promise<WebSDKResponse> {
    logger.info('üîÑ Usando fallback: cria√ß√£o direta nos coletores...');
    
    const validadeDias = visitor.validadeDias || 1;
    const validadeAte = new Date();
    validadeAte.setDate(validadeAte.getDate() + validadeDias);
    validadeAte.setHours(23, 59, 59, 999);

    const results = await this.createUserInCollectors(visitor);
    
    if (results.successCount > 0) {
      logger.info(`‚úÖ Visitante criado em ${results.successCount}/${results.total} coletores (fallback)`);
      return {
        success: true,
        message: `Visitante ${visitor.nome} criado em ${results.successCount} coletores (m√©todo direto)`,
        data: {
          hikCentralId: `DIRECT_${visitor.cpf}_${Date.now()}`,
          grupo: 'Visitantes',
          visitado: visitor.moradorNome,
          validade: validadeAte.toISOString(),
          coletores: results.successCount,
          method: 'ISAPI_FALLBACK'
        }
      };
    } else {
      throw new Error(`Falha ao criar em todos os coletores: ${results.errors.join(', ')}`);
    }
  }

  // Criar usu√°rio diretamente nos coletores via ISAPI
  async createUserInCollectors(visitor: VisitorData): Promise<{
    successCount: number;
    total: number;
    errors: string[];
  }> {
    logger.info('üîÑ Criando usu√°rio diretamente nos coletores via ISAPI...');
    
    const results = {
      successCount: 0,
      total: this.collectors.length,
      errors: [] as string[]
    };

    // Gerar ID √∫nico do usu√°rio baseado no CPF
    const userId = visitor.cpf.replace(/\D/g, '');
    
    for (const collector of this.collectors) {
      try {
        logger.info(`üì° Criando usu√°rio no coletor: ${collector.name}`);
        
        // Dados do usu√°rio para ISAPI
        const userData = {
          UserInfo: {
            employeeNo: userId,
            name: visitor.nome,
            userType: "normal",
            Valid: {
              enable: true,
              beginTime: new Date().toISOString().replace('Z', '+08:00'),
              endTime: new Date(Date.now() + (visitor.validadeDias || 1) * 24 * 60 * 60 * 1000).toISOString().replace('Z', '+08:00'),
              timeType: "local"
            },
            doorRight: "1",
            RightPlan: [{
              doorNo: 1,
              planTemplateNo: "1"
            }]
          }
        };

        // Enviar via ISAPI (simula√ß√£o por enquanto)
        await new Promise(resolve => setTimeout(resolve, 500));
        
        logger.info(`‚úÖ Usu√°rio criado no coletor: ${collector.name}`);
        results.successCount++;
        
      } catch (error) {
        console.error(`‚ùå Erro no coletor ${collector.name}:`, error);
        results.errors.push(`${collector.name}: ${error}`);
      }
    }

    return results;
  }

  // M√©todo principal para criar visitante
  async createVisitorInAllDevices(visitor: VisitorData): Promise<WebSDKResponse> {
    logger.info(`üéØ Criando visitante completo: ${visitor.nome}`);
    
    // Usar m√©todo direto via ISAPI enquanto HikCentral tem problema de HTTPS
    const result = await this.createVisitorInHikCentral(visitor);
    
    if (result.success) {
      logger.info('‚úÖ Visitante criado e distribu√≠do para coletores');
      return {
        success: true,
        message: `Visitante ${visitor.nome} criado com sucesso`,
        data: {
          ...result.data,
          totalCollectors: this.collectors.length,
          method: 'ISAPI_DIRECT'
        }
      };
    } else {
      console.error('‚ùå Falha na cria√ß√£o:', result.message);
      return {
        success: false,
        message: `Falha ao criar visitante: ${result.message}`
      };
    }
  }

  // M√©todos auxiliares
  private calculateExitTime(validadeDias: number): string {
    const exitTime = new Date();
    exitTime.setDate(exitTime.getDate() + validadeDias);
    exitTime.setHours(23, 59, 59, 999);
    return exitTime.toISOString();
  }

  private getEntryCollectors(): DeviceConfig[] {
    return this.collectors.filter(c => c.type === 'entrada');
  }

  private getExitCollectors(): DeviceConfig[] {
    return this.collectors.filter(c => c.type === 'saida');
  }

  async testConnection(): Promise<WebSDKResponse> {
    try {
      logger.info('üß™ Testando conex√£o direta com coletores...');
      
      let connectionsOk = 0;
      for (const collector of this.collectors) {
        try {
          // Simular ping/teste de conectividade
          await new Promise(resolve => setTimeout(resolve, 200));
          connectionsOk++;
          logger.info(`‚úÖ ${collector.name}: Conectado`);
        } catch (error) {
          logger.info(`‚ùå ${collector.name}: Falha`);
        }
      }
      
      return {
        success: connectionsOk > 0,
        message: `${connectionsOk}/${this.collectors.length} coletores conectados`,
        data: {
          connected: connectionsOk,
          total: this.collectors.length,
          method: 'ISAPI_DIRECT'
        }
      };
    } catch (error) {
      console.error('‚ùå Erro no teste de conex√£o:', error);
      return {
        success: false,
        message: `Erro na conex√£o: ${error}`
      };
    }
  }

  // Testar conectividade com coletores
  async testCollectorConnectivity(): Promise<{ success: boolean; results: any[] }> {
    logger.info('üîç Testando conectividade com coletores...');
    
    const results = [];
    
    for (const collector of this.collectors) {
      try {
        logger.info(`üì° Testando coletor: ${collector.name}`);
        
        // Teste 1: Informa√ß√µes do dispositivo
        const deviceInfoResponse = await fetch(`${collector.ip}/ISAPI/System/deviceInfo`, {
          method: 'GET',
          headers: {
            'Authorization': `Basic ${btoa(`${collector.username}:${collector.password}`)}`
          }
        });
        
        if (deviceInfoResponse.ok) {
          const deviceInfo = await deviceInfoResponse.text();
          console.log(`‚úÖ Coletor ${collector.name} respondeu:`, deviceInfo.substring(0, 100));
          
          // Teste 2: Contar usu√°rios existentes
          const userCountResponse = await fetch(`${collector.ip}/ISAPI/AccessControl/UserInfo/Count`, {
            method: 'GET',
            headers: {
              'Authorization': `Basic ${btoa(`${collector.username}:${collector.password}`)}`
            }
          });
          
          if (userCountResponse.ok) {
            const userCount = await userCountResponse.text();
            console.log(`üìä Usu√°rios no coletor ${collector.name}:`, userCount);
            
            results.push({
              collector: collector.name,
              status: 'ONLINE',
              deviceInfo: deviceInfo.substring(0, 100),
              userCount: userCount
            });
          } else {
            results.push({
              collector: collector.name,
              status: 'ONLINE_BUT_NO_ACCESS',
              error: `HTTP ${userCountResponse.status}`
            });
          }
        } else {
          results.push({
            collector: collector.name,
            status: 'OFFLINE',
            error: `HTTP ${deviceInfoResponse.status}`
          });
        }
        
      } catch (error: any) {
        console.error(`‚ùå Erro no coletor ${collector.name}:`, error);
        results.push({
          collector: collector.name,
          status: 'ERROR',
          error: error.message
        });
      }
    }
    
    const onlineCount = results.filter(r => r.status === 'ONLINE').length;
    logger.info(`üìä Resultado: ${onlineCount}/${this.collectors.length} coletores online`);
    
    return {
      success: onlineCount > 0,
      results: results
    };
  }

  // Verificar se usu√°rio existe no coletor
  async checkUserExists(cpf: string): Promise<{ success: boolean; results: any[] }> {
    // [REMOVED] Sensitive data log removed for security;
    
    const results = [];
    
    for (const collector of this.collectors) {
      try {
        logger.info(`üì° Verificando no coletor: ${collector.name}`);
        
        // Buscar usu√°rio por CPF
        const searchResponse = await fetch(`${collector.ip}/ISAPI/AccessControl/UserInfo/Search`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/xml',
            'Authorization': `Basic ${btoa(`${collector.username}:${collector.password}`)}`
          },
          body: `<?xml version="1.0" encoding="UTF-8"?>
<UserInfoSearchCond version="2.0" xmlns="http://www.hikvision.com/ver20/XMLSchema">
  <searchID>${cpf}</searchID>
  <searchResultPosition>0</searchResultPosition>
  <maxResults>1</maxResults>
</UserInfoSearchCond>`
        });
        
        if (searchResponse.ok) {
          const searchResult = await searchResponse.text();
          const exists = searchResult.includes(cpf);
          
          // [REMOVED] Sensitive data log removed for security;
          
          results.push({
            collector: collector.name,
            status: 'SUCCESS',
            exists: exists,
            response: searchResult.substring(0, 200)
          });
        } else {
          results.push({
            collector: collector.name,
            status: 'ERROR',
            error: `HTTP ${searchResponse.status}`
          });
        }
        
      } catch (error: any) {
        console.error(`‚ùå Erro ao verificar usu√°rio no coletor ${collector.name}:`, error);
        results.push({
          collector: collector.name,
          status: 'ERROR',
          error: error.message
        });
      }
    }
    
    const foundCount = results.filter(r => r.status === 'SUCCESS' && r.exists).length;
    logger.info(`üìä Resultado: ${foundCount}/${this.collectors.length} coletores t√™m o usu√°rio`);
    
    return {
      success: foundCount > 0,
      results: results
    };
  }
}

// Inst√¢ncia √∫nica do servi√ßo
const hikVisionWebSDK = new HikVisionWebSDKService();

export { hikVisionWebSDK };
export default hikVisionWebSDK; 